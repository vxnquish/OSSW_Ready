name: Main Branch CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  JAR_NAME: 'lovemap_backend'
  JAVA_VERSION: '17'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('backend/**/*.gradle*', 'backend/**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Create application configuration files
        run: |
          mkdir -p ./src/main/resources
          
          # application.properties ìƒì„±
          if [ -n "${{ secrets.APPLICATION_PROPERTIES }}" ]; then
            echo "${{ secrets.APPLICATION_PROPERTIES }}" > ./src/main/resources/application.properties
            echo "âœ… application.properties created"
          fi

          echo "ğŸ“ Configuration files:"
          ls -la ./src/main/resources/application.* || echo "No application config files found"
        working-directory: backend
        shell: bash

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        working-directory: backend

      - name: Build without running tests
        run: ./gradlew bootJar -x test
        working-directory: backend

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: test-results
          path: backend/build/reports/tests/

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      jar-version: ${{ steps.build-info.outputs.jar-version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('backend/**/*.gradle*', 'backend/**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Create application configuration files
        run: |
          mkdir -p ./src/main/resources
          echo "${{ secrets.APPLICATION_PROPERTIES }}" > ./src/main/resources/application.properties
        working-directory: backend
        shell: bash

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        working-directory: backend

      - name: Build with Gradle
        run: ./gradlew clean build -x test --no-daemon
        working-directory: backend

      - name: Get build info
        id: build-info
        run: |
          JAR_FILE=$(find build/libs -name "${JAR_NAME}-*.jar" ! -name '*plain.jar' | head -n 1)
          if [ -z "$JAR_FILE" ]; then
            echo "âŒ Error: JAR file not found"
            echo "Available files:"
            ls -la build/libs/ || echo "build/libs directory not found"
            exit 1
          fi
          
          JAR_VERSION=$(basename "$JAR_FILE" | sed "s/${JAR_NAME}-//g" | sed 's/.jar//g')
          echo "jar-version=$JAR_VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Built JAR: $(basename $JAR_FILE)"
          echo "ğŸ“Š JAR Size: $(du -h $JAR_FILE | cut -f1)"
        working-directory: backend

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.JAR_NAME }}
          path: backend/build/libs/${{ env.JAR_NAME }}-*.jar
          retention-days: 7

  deploy:
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.JAR_NAME }}
          path: build/libs/

      - name: Prepare deployment
        id: prepare
        run: |
          JAR_FILE=$(find build/libs -name "${JAR_NAME}-*.jar" | head -n 1)
          if [ -z "$JAR_FILE" ]; then
            echo "âŒ Error: Downloaded JAR file not found"
            exit 1
          fi
          
          echo "jar-file=$JAR_FILE" >> $GITHUB_OUTPUT
          echo "ğŸš€ Preparing to deploy: $(basename $JAR_FILE)"

      - name: Deploy to EC2 Server
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          # SSH í‚¤ ì„¤ì •
          echo "$EC2_SSH_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          JAR_FILE="${{ steps.prepare.outputs.jar-file }}"
          TARGET_JAR_NAME="${{ env.JAR_NAME }}.jar"
          
          echo "ğŸ” Source JAR: $(basename $JAR_FILE)"
          echo "ğŸ¯ Target JAR: $TARGET_JAR_NAME"
          
          # ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸
          echo "ğŸ”Œ Testing server connection..."
          ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            $EC2_USERNAME@$EC2_HOST "echo 'âœ… Server connection successful'"
          
          # ë°±ì—… ìƒì„±
          echo "ğŸ“¦ Creating backup..."
          ssh -i private_key.pem -o StrictHostKeyChecking=no $EC2_USERNAME@$EC2_HOST "
            if [ -f /home/$EC2_USERNAME/$TARGET_JAR_NAME ]; then
              cp /home/$EC2_USERNAME/$TARGET_JAR_NAME /home/$EC2_USERNAME/${TARGET_JAR_NAME}.backup
              echo 'âœ… Backup created: ${TARGET_JAR_NAME}.backup'
            else
              echo 'â„¹ï¸  No existing application to backup'
            fi
          "
          
          # JAR íŒŒì¼ ì—…ë¡œë“œ
          echo "â¬†ï¸  Uploading JAR file..."
          scp -i private_key.pem -o StrictHostKeyChecking=no \
            "$JAR_FILE" $EC2_USERNAME@$EC2_HOST:/home/$EC2_USERNAME/$TARGET_JAR_NAME
          
          echo "âœ… JAR file uploaded successfully"
          
          # ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬
          echo "ğŸš€ Starting deployment..."
          ssh -i private_key.pem -o StrictHostKeyChecking=no $EC2_USERNAME@$EC2_HOST "
            echo 'ğŸ”„ Deployment process starting...'
          
            # ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            if pgrep -f '$TARGET_JAR_NAME' > /dev/null; then
              echo 'â¹ï¸  Stopping existing application...'
              pkill -TERM -f '$TARGET_JAR_NAME'
          
              # Graceful shutdown ëŒ€ê¸°
              for i in {1..15}; do
                if ! pgrep -f '$TARGET_JAR_NAME' > /dev/null; then
                  echo 'âœ… Application stopped gracefully'
                  break
                fi
                echo \"â³ Waiting for graceful shutdown... (\$i/15)\"
                sleep 1
              done
          
              # ê°•ì œ ì¢…ë£Œê°€ í•„ìš”í•œ ê²½ìš°
              if pgrep -f '$TARGET_JAR_NAME' > /dev/null; then
                echo 'ğŸ”¨ Force killing application...'
                pkill -KILL -f '$TARGET_JAR_NAME'
                sleep 2
              fi
            else
              echo 'â„¹ï¸  No existing application running'
            fi
          
            # ìƒˆ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
            echo 'ğŸš€ Starting new application...'
            nohup java -jar \
              -Dspring.profiles.active=prod \
              -Dserver.port=8080 \
              -Xms1024m -Xmx2048m \
              -Dfile.encoding=UTF-8 \
              -Djava.awt.headless=true \
              -XX:+UseG1GC \
              -XX:+UseStringDeduplication \
              /home/$EC2_USERNAME/$TARGET_JAR_NAME > app.log 2>&1 &
          
            APP_PID=\$!
            echo \"ğŸ“‹ Application PID: \$APP_PID\"
          
            # ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ëŒ€ê¸°
            echo 'â³ Waiting for application to start...'
            sleep 30
          
            # í”„ë¡œì„¸ìŠ¤ í™•ì¸
            if pgrep -f '$TARGET_JAR_NAME' > /dev/null; then
              echo 'âœ… Application process is running'
          
              # í¬íŠ¸ í™•ì¸
              sleep 10
              if netstat -tlnp | grep :8080 > /dev/null; then
                echo 'âœ… Application is listening on port 8080'
          
                # í—¬ìŠ¤ì²´í¬ (Actuatorê°€ ìˆëŠ” ê²½ìš°)
                if curl -f -m 10 http://localhost:8080/actuator/health > /dev/null 2>&1; then
                  echo 'âœ… Health check passed'
                elif curl -f -m 10 http://localhost:8080/ > /dev/null 2>&1; then
                  echo 'âœ… Application root endpoint is responding'
                else
                  echo 'âš ï¸  Health check endpoint not available, but application seems to be running'
                fi
          
                echo 'ğŸ‰ Deployment completed successfully!'
              else
                echo 'âŒ Application is not listening on port 8080'
                echo 'ğŸ“‹ Last 20 lines of application log:'
                tail -20 app.log
                exit 1
              fi
            else
              echo 'âŒ Application process is not running'
              echo 'ğŸ“‹ Application log:'
              tail -50 app.log
              exit 1
            fi
          "
          
          # ì •ë¦¬
          rm -f private_key.pem
          echo "ğŸ§¹ Cleanup completed"

      - name: Deployment Summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "ğŸ‰ âœ… Production deployment successful!"
            echo "ğŸŒ Application URL: http://${{ secrets.EC2_HOST }}:8080"
            echo "ğŸ“Š Server: ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}"
            echo "ğŸ”§ Environment: Production"
            echo "ğŸ“¦ JAR: ${{ env.JAR_NAME }}.jar"
          else
            echo "ğŸ’¥ âŒ Production deployment failed!"
            echo "ğŸ” Please check the logs above for error details"
            echo "ğŸ”„ You can restore the backup if needed:"
            echo "   ssh user@server 'mv ${{ env.JAR_NAME }}.jar.backup ${{ env.JAR_NAME }}.jar'"
          fi